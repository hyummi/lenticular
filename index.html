<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lenticular / Moiré Playground</title>
  <style>
    :root {
      color-scheme: dark;
      --stripe-size: 4px;
      --angle: 0deg;
      --speed: 8s;
      --offset: 0px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 24px;
      background: radial-gradient(circle at 20% 20%, #1e293b 0, #0f172a 40%, #0b1220 70%);
      color: #e2e8f0;
      min-height: 100vh;
    }

    h1 {
      font-weight: 700;
      letter-spacing: -0.02em;
      margin: 0 0 6px;
    }

    p {
      margin: 0 0 16px;
      color: #cbd5e1;
    }

    .card {
      background: rgba(15, 23, 42, 0.65);
      border: 1px solid rgba(148, 163, 184, 0.2);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
      border-radius: 16px;
      padding: 18px;
      backdrop-filter: blur(8px);
      max-width: 1040px;
      margin: 0 auto;
    }

    .viewer {
      position: relative;
      margin-top: 14px;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: #0b1220;
      min-height: 420px;
      display: grid;
      place-items: center;
    }

    #photoA,
    #photoB {
      position: absolute;
      inset: 0;
      max-height: 640px;
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0;
      transition: opacity 280ms ease;
      display: block;
      background: #0b1220;
    }

    .viewer.ready #photoA,
    .viewer.ready #photoB {
      opacity: 1;
    }

    /* Interlacing masks */
    #photoA {
      mask-image: repeating-linear-gradient(
        90deg,
        #000 0,
        #000 calc(var(--interlace-size, 8px) * 0.5),
        transparent calc(var(--interlace-size, 8px) * 0.5),
        transparent var(--interlace-size, 8px)
      );
      -webkit-mask-image: repeating-linear-gradient(
        90deg,
        #000 0,
        #000 calc(var(--interlace-size, 8px) * 0.5),
        transparent calc(var(--interlace-size, 8px) * 0.5),
        transparent var(--interlace-size, 8px)
      );
    }

    #photoB {
      mask-image: repeating-linear-gradient(
        90deg,
        transparent 0,
        transparent calc(var(--interlace-size, 8px) * 0.5),
        #000 calc(var(--interlace-size, 8px) * 0.5),
        #000 var(--interlace-size, 8px)
      );
      -webkit-mask-image: repeating-linear-gradient(
        90deg,
        transparent 0,
        transparent calc(var(--interlace-size, 8px) * 0.5),
        #000 calc(var(--interlace-size, 8px) * 0.5),
        #000 var(--interlace-size, 8px)
      );
    }

    #moireOverlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.55;
      background: repeating-linear-gradient(
        var(--angle, 10deg),
        rgba(255, 255, 255, 0) 0,
        rgba(255, 255, 255, 0) calc(var(--stripe-size, 8px) * 0.5),
        rgba(0, 0, 0, 0.9) calc(var(--stripe-size, 8px) * 0.5),
        rgba(0, 0, 0, 0.9) var(--stripe-size, 8px)
      );
      mix-blend-mode: difference;
      transform: translateX(var(--offset, 0px));
      animation: drift var(--speed, 6s) linear infinite;
    }

    @keyframes drift {
      from {
        transform: translateX(calc(-1 * var(--stripe-size, 8px)));
      }
      to {
        transform: translateX(var(--stripe-size, 8px));
      }
    }

    .controls {
      margin-top: 16px;
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
    }

    .control {
      background: rgba(30, 41, 59, 0.4);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      padding: 12px;
      display: grid;
      gap: 6px;
    }

    .control label {
      font-weight: 600;
      font-size: 13px;
      color: #cbd5e1;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    input[type="range"] {
      width: 100%;
      accent-color: #67e8f9;
    }

    .hint {
      font-size: 13px;
      color: #94a3b8;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .flex {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .toggle {
      appearance: none;
      width: 42px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(148, 163, 184, 0.25);
      position: relative;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease;
    }

    .toggle::after {
      content: "";
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #e2e8f0;
      top: 2px;
      left: 2px;
      transition: transform 160ms ease, background 160ms ease;
    }

    .toggle:checked {
      background: rgba(94, 234, 212, 0.3);
      border-color: rgba(94, 234, 212, 0.8);
    }

    .toggle:checked::after {
      transform: translateX(18px);
      background: #67e8f9;
    }

    .placeholder {
      color: #94a3b8;
      font-weight: 500;
    }

    input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(30, 41, 59, 0.35);
      color: #e2e8f0;
      font-size: 14px;
      outline: none;
      transition: border-color 140ms ease, background 140ms ease;
    }

    input[type="text"]:focus {
      border-color: rgba(94, 234, 212, 0.7);
      background: rgba(30, 41, 59, 0.5);
    }

    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(94, 234, 212, 0.6);
      background: rgba(94, 234, 212, 0.12);
      color: #67e8f9;
      font-weight: 700;
      cursor: pointer;
      transition: background 140ms ease, transform 120ms ease;
    }

    button:active {
      transform: translateY(1px);
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Lenticular / Moiré Preview</h1>
    <p>Add two images; stripes reveal alternating rows/columns to create the lenticular effect. Adjust stripe size and overlay as needed.</p>

    <div class="control" style="margin-top:10px; display:grid; gap:10px;">
      <label>Image A URL</label>
      <input id="imageUrlA" type="text" placeholder="https://example.com/photo-a.jpg" />
      <label>Image B URL</label>
      <input id="imageUrlB" type="text" placeholder="https://example.com/photo-b.jpg" />
      <div class="hint">Use CORS-friendly images (most CDNs/hosted images work).</div>
      <button id="loadBtn">Load both images</button>
    </div>

    <div class="viewer" id="viewer">
      <span class="placeholder">Your image will appear here</span>
      <img id="photoA" alt="Image A" />
      <img id="photoB" alt="Image B" />
      <div id="moireOverlay" aria-hidden="true"></div>
    </div>

    <div class="controls">
      <div class="control">
        <label>Stripe size <span id="stripeValue">4px</span></label>
        <input id="stripeRange" type="range" min="2" max="40" value="4" />
      </div>
      <div class="control">
        <label>Angle <span id="angleValue">0°</span></label>
        <input id="angleRange" type="range" min="0" max="90" value="0" />
      </div>
      <div class="control">
        <label>Overlay opacity <span id="opacityValue">0.65</span></label>
        <input id="opacityRange" type="range" min="0.1" max="1" step="0.05" value="0.65" />
      </div>
      <div class="control">
        <label>Drift speed <span id="speedValue">8s</span></label>
        <input id="speedRange" type="range" min="2" max="20" value="8" />
      </div>
      <div class="control">
        <label>Manual offset <span id="offsetValue">0px</span></label>
        <input id="offsetRange" type="range" min="-60" max="60" value="0" />
      </div>
      <div class="control">
        <label class="flex">
          <span>Animate stripes</span>
          <input id="animateToggle" class="toggle" type="checkbox" checked />
        </label>
        <div class="hint">Turn off to scrub the overlay manually.</div>
      </div>
      <div class="control">
        <label class="flex">
          <span>Tilt to parallax</span>
          <input id="tiltToggle" class="toggle" type="checkbox" />
        </label>
        <div class="hint">iOS requires motion permission the first time.</div>
        <label> Tilt sensitivity <span id="tiltValue">0.6</span></label>
        <input id="tiltRange" type="range" min="0.1" max="1.5" step="0.1" value="0.6" />
      </div>
      <div class="control">
        <label>Quick preset</label>
        <button id="presetBtn">Apply moiré preset</button>
        <div class="hint">Uses tight vertical stripes and moderate opacity.</div>
      </div>
    </div>
  </div>

  <script>
    const imageUrlA = document.getElementById("imageUrlA");
    const imageUrlB = document.getElementById("imageUrlB");
    const loadBtn = document.getElementById("loadBtn");
    const photoA = document.getElementById("photoA");
    const photoB = document.getElementById("photoB");
    const viewer = document.getElementById("viewer");
    const overlay = document.getElementById("moireOverlay");

    const stripeRange = document.getElementById("stripeRange");
    const angleRange = document.getElementById("angleRange");
    const opacityRange = document.getElementById("opacityRange");
    const speedRange = document.getElementById("speedRange");
    const offsetRange = document.getElementById("offsetRange");
    const animateToggle = document.getElementById("animateToggle");
    const tiltToggle = document.getElementById("tiltToggle");
    const tiltRange = document.getElementById("tiltRange");
    const presetBtn = document.getElementById("presetBtn");

    const stripeValue = document.getElementById("stripeValue");
    const angleValue = document.getElementById("angleValue");
    const opacityValue = document.getElementById("opacityValue");
    const speedValue = document.getElementById("speedValue");
    const offsetValue = document.getElementById("offsetValue");
    const tiltValue = document.getElementById("tiltValue");

    let tiltActive = false;
    let tiltListenerAttached = false;

    const setOverlay = () => {
      overlay.style.setProperty("--stripe-size", `${stripeRange.value}px`);
      overlay.style.setProperty("--interlace-size", `${stripeRange.value}px`);
      overlay.style.setProperty("--angle", `${angleRange.value}deg`);
      overlay.style.setProperty("--offset", `${offsetRange.value}px`);
      overlay.style.setProperty("--speed", `${speedRange.value}s`);
      overlay.style.opacity = opacityRange.value;

      stripeValue.textContent = `${stripeRange.value}px`;
      angleValue.textContent = `${angleRange.value}°`;
      opacityValue.textContent = opacityRange.value;
      speedValue.textContent = `${speedRange.value}s`;
      offsetValue.textContent = `${offsetRange.value}px`;
      tiltValue.textContent = tiltRange.value;

      overlay.style.animationPlayState = animateToggle.checked ? "running" : "paused";
      overlay.style.transform = animateToggle.checked
        ? ""
        : `translateX(${offsetRange.value}px)`;
    };

    const handleTilt = (event) => {
      if (!tiltActive) return;
      const gamma = event.gamma ?? 0; // left-right tilt
      const clamped = Math.max(-30, Math.min(30, gamma));
      const shift = (clamped / 30) * 60 * parseFloat(tiltRange.value); // max 60px shift scaled by sensitivity
      overlay.style.animationPlayState = "paused";
      overlay.style.transform = `translateX(${shift}px)`;
      offsetValue.textContent = `${shift.toFixed(1)}px`;
    };

    const requestTiltPermission = async () => {
      if (typeof DeviceMotionEvent === "undefined" && typeof DeviceOrientationEvent === "undefined") return true;
      const perm = DeviceOrientationEvent?.requestPermission;
      if (typeof perm === "function") {
        try {
          const res = await perm();
          return res === "granted";
        } catch (e) {
          console.warn("Permission request failed", e);
          return false;
        }
      }
      return true; // non-iOS browsers
    };

    const enableTilt = async (enabled) => {
      tiltActive = enabled;
      if (!enabled) {
        overlay.style.animationPlayState = animateToggle.checked ? "running" : "paused";
        setOverlay();
        return;
      }
      const ok = await requestTiltPermission();
      if (!ok) {
        tiltToggle.checked = false;
        tiltActive = false;
        return;
      }
      if (!tiltListenerAttached) {
        window.addEventListener("deviceorientation", handleTilt, true);
        window.addEventListener("devicemotion", (e) => {
          if (!tiltActive) return;
          // fallback using acceleration including gravity; approximate gamma
          const gx = e.accelerationIncludingGravity?.x ?? 0;
          const shift = Math.max(-1, Math.min(1, gx / 9.8)) * 60 * parseFloat(tiltRange.value);
          overlay.style.animationPlayState = "paused";
          overlay.style.transform = `translateX(${shift}px)`;
          offsetValue.textContent = `${shift.toFixed(1)}px`;
        }, true);
        tiltListenerAttached = true;
      }
      overlay.style.animationPlayState = "paused";
    };

    const loadImageFromUrl = (imgEl, url) => {
      if (!url) return;
      imgEl.crossOrigin = "anonymous";
      imgEl.onload = () => {
        if (photoA.complete && photoB.complete) viewer.classList.add("ready");
      };
      imgEl.onerror = () => alert("Could not load that image. Check the URL/CORS.");
      imgEl.src = url;
    };

    const loadBoth = () => {
      viewer.classList.remove("ready");
      loadImageFromUrl(photoA, imageUrlA.value.trim());
      loadImageFromUrl(photoB, imageUrlB.value.trim());
    };

    loadBtn.addEventListener("click", loadBoth);

    [imageUrlA, imageUrlB].forEach((input) =>
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") loadBoth();
      })
    );

    presetBtn.addEventListener("click", () => {
      stripeRange.value = 4;
      angleRange.value = 0;
      opacityRange.value = 0.65;
      speedRange.value = 8;
      offsetRange.value = 0;
      animateToggle.checked = true;
      setOverlay();
    });

    [stripeRange, angleRange, opacityRange, speedRange, offsetRange, animateToggle].forEach(
      (el) => el.addEventListener("input", setOverlay)
    );

    tiltRange.addEventListener("input", () => {
      tiltValue.textContent = tiltRange.value;
    });

    tiltToggle.addEventListener("change", (e) => {
      enableTilt(e.target.checked);
    });

    setOverlay();
    const defaultImageA = "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?w=1200&auto=format&fit=crop&q=80";
    const defaultImageB = "https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?w=1200&auto=format&fit=crop&q=80";
    imageUrlA.value = defaultImageA;
    imageUrlB.value = defaultImageB;
    loadImageFromUrl(photoA, defaultImageA);
    loadImageFromUrl(photoB, defaultImageB);
  </script>
</body>
</html>

